Single Responsiblity Principle
(Class only has one job to do/ serperate responsibilies)


Open Close Prinicple
(If it ain't broke, don't fix it)
New features should be implemented with new code, not changing the old code.
Use abstract and override.


Liskov's Substitution Principle
(Think ducks! Parent class is duck, if child class is mechanical duck then you're quacking at the wrong tree. Mechanic duck uses batteries. Need female ducks)

Intergration Segregation Principle
Fat code is no go, no client should be forced to use code it does not need, don't overload classes with a bunch of methods like I'm doing with already long sentence by putting in a lot of unnecessory jibber jabble and go make a sandwich. 

Dependency Inversion Principle 
It's really late. I should go to bed.
High level modules (Program) depending on low level modules. Both high and low levels should depend on abstractions.
Abstractions should not depend on details. 
Basically.. a developer should be able to chuck in codeout with breaking anything in the process. 
One way to implement dependency inversion could be to use something called dependency injection 

Notes
- Took "Update" out of IUserInterfaceElement. By taking out the Update method, we are preventing the IUserInterfaceElement class from potentially doing too much (Single Responsiblity Prinicple).

- Seperated books into fiction and non fiction. The library may want to have fiction books in the future. It has magazines so why not? Obviously fiction books will have different categories.
It is logical to seperate the fiction and non-fiction categories as they are so different. Fiction will have genres. Non-fiction can use categories. 

- App.cs looks like it's doing too much. Saving things into JSON or XML (which doesn't currently exist, so a whole load of code for nothing)

- The Input method is annoying. It only outputs a colon.. But Open Close Prinicple says we should not change anything if it isn't broken? Maybe?